% ============================================================================
% Appendix D: Formal Specifications
% ============================================================================

\section{Formal Specifications}
\label{appendix:formal}

This appendix provides formal state machine specifications for the \Botho
protocol, suitable for verification and implementation reference.

\subsection{State Definitions}

\subsubsection{Blockchain State}

The blockchain state $\Sigma$ is a tuple:

\begin{equation}
\Sigma = (\mathcal{U}, \mathcal{I}, \mathcal{C}, h, t)
\end{equation}

where:
\begin{itemize}
  \item $\mathcal{U}$: UTXO set (unspent transaction outputs)
  \item $\mathcal{I}$: Key image set (spent output identifiers)
  \item $\mathcal{C}$: Cluster tag database
  \item $h$: Current block height
  \item $t$: Latest block timestamp
\end{itemize}

\textbf{UTXO Structure}:
\begin{lstlisting}[caption={Formal UTXO definition}]
UTXO = {
    outpoint: (block_height, tx_index, output_index),
    commitment: CompressedPoint,  // Pedersen commitment
    one_time_key: CompressedPoint,
    kem_ciphertext: [u8; 1088],
    cluster_tag: ClusterTag,
    created_height: u64,
}

ClusterTag = {
    weights: Map<ClusterId, Rational>,  // Sum to 1
}
\end{lstlisting}

\textbf{Key Image Set}:
\begin{equation}
\mathcal{I} = \{ I \in \mathbb{G} : I \text{ has been spent} \}
\end{equation}

Key images are deterministic: $I = x \cdot \Hp(P)$ where $x$ is the private
key and $P$ is the one-time public key.

\subsubsection{Consensus State}

The SCP consensus state $\Xi$ for slot $s$ is:

\begin{equation}
\Xi_s = (\phi_s, \beta_s, M_s, V_s)
\end{equation}

where:
\begin{itemize}
  \item $\phi_s \in \{\text{NOMINATING}, \text{PREPARING}, \text{COMMITTING}, \text{EXTERNALIZED}\}$
  \item $\beta_s$: Current ballot $(n, v)$ where $n$ is counter, $v$ is value
  \item $M_s$: Set of received messages
  \item $V_s$: Set of nominated values
\end{itemize}

\subsection{State Transition Functions}

\subsubsection{Block Application}

The state transition function $\delta: \Sigma \times B \to \Sigma$ applies
block $B$ to state $\Sigma$:

\begin{lstlisting}[caption={Block application function}]
function apply_block(state: State, block: Block) -> Result<State> {
    // 1. Verify block header
    require(block.prev_hash == hash(state.latest_block))
    require(block.height == state.height + 1)
    require(verify_pow(block.header))

    // 2. Verify minting transaction
    let reward = compute_block_reward(block.height)
    require(sum(block.minting_tx.outputs) <= reward)
    require(verify_mldsa(block.minting_tx.signature))

    // 3. Apply each transaction
    let new_state = state
    for tx in block.transactions {
        new_state = apply_transaction(new_state, tx)?
    }

    // 4. Add minting outputs to UTXO set
    for (i, output) in block.minting_tx.outputs.enumerate() {
        let utxo = create_utxo(block, 0, i, output)
        new_state.utxo_set.insert(utxo)
    }

    // 5. Process fee redistribution
    new_state = process_fees(new_state, block)?

    // 6. Update metadata
    new_state.height = block.height
    new_state.timestamp = block.timestamp
    new_state.latest_block = hash(block)

    Ok(new_state)
}
\end{lstlisting}

\subsubsection{Transaction Application}

The transaction application function:

\begin{lstlisting}[caption={Transaction application function}]
function apply_transaction(
    state: State,
    tx: Transaction
) -> Result<State> {
    // 1. Validate transaction structure
    require(1 <= tx.inputs.len() <= 16)
    require(1 <= tx.outputs.len() <= 16)

    // 2. Check key image uniqueness
    for input in tx.inputs {
        require(!state.key_images.contains(input.key_image))
    }

    // 3. Verify ring signatures
    for (input, signature) in zip(tx.inputs, tx.signatures) {
        let ring = get_ring_members(state, input.ring)
        require(verify_clsag(signature, ring, tx.prefix_hash))
    }

    // 4. Verify value conservation
    let input_sum = sum_commitments(get_input_commitments(tx))
    let output_sum = sum_commitments(tx.outputs.map(|o| o.commitment))
    let fee_point = tx.fee * H
    require(input_sum == output_sum + fee_point)

    // 5. Verify range proofs
    require(verify_bulletproof(tx.bulletproof, tx.outputs))

    // 6. Check minimum fee
    let cluster_factor = compute_cluster_factor(tx)
    let min_fee = base_fee * tx.size * cluster_factor
    require(tx.fee >= min_fee)

    // 7. Apply state changes
    let mut new_state = state

    // Remove spent outputs (we don't know which, but add key images)
    for input in tx.inputs {
        new_state.key_images.insert(input.key_image)
    }

    // Add new outputs
    for (i, output) in tx.outputs.enumerate() {
        let utxo = create_utxo_from_output(tx, i, output)
        new_state.utxo_set.insert(utxo)
    }

    Ok(new_state)
}
\end{lstlisting}

\subsubsection{Fee Processing}

Fee redistribution follows the 80/20 lottery/burn model:

\begin{lstlisting}[caption={Fee processing function}]
function process_fees(state: State, block: Block) -> State {
    let total_fees = sum(block.transactions.map(|tx| tx.fee))
    let lottery_pool = 0.8 * total_fees
    let burn_amount = 0.2 * total_fees  // Destroyed

    // Select lottery winners using deterministic randomness
    let seed = hash(block.prev_hash || block.merkle_root)
    let num_winners = 5
    let winners = select_random_utxos(state.utxo_set, seed, num_winners)

    // Distribute lottery pool
    let per_winner = lottery_pool / num_winners
    for winner_outpoint in winners {
        // Create lottery payout transaction
        let payout = create_lottery_payout(winner_outpoint, per_winner)
        state = apply_lottery_payout(state, payout)
    }

    state
}

function select_random_utxos(
    utxo_set: Set<UTXO>,
    seed: Hash,
    count: usize
) -> Vec<Outpoint> {
    let utxos: Vec<UTXO> = utxo_set.to_sorted_vec()
    let mut selected = Vec::new()

    for i in 0..count {
        let index = hash_to_index(seed, i, utxos.len())
        selected.push(utxos[index].outpoint)
    }

    selected
}
\end{lstlisting}

\subsection{Validity Predicates}

\subsubsection{Transaction Validity}

A transaction $T$ is valid with respect to state $\Sigma$ iff:

\begin{equation}
\text{Valid}(T, \Sigma) \Leftrightarrow \bigwedge_{i=1}^{8} P_i(T, \Sigma)
\end{equation}

where predicates $P_i$ are:

\begin{enumerate}
  \item $P_1$: \textbf{Structure}
    \[
    1 \leq |T.\text{inputs}| \leq 16 \land 1 \leq |T.\text{outputs}| \leq 16
    \]

  \item $P_2$: \textbf{Key Image Freshness}
    \[
    \forall I \in T.\text{key\_images}: I \notin \Sigma.\mathcal{I}
    \]

  \item $P_3$: \textbf{Key Image Uniqueness (intra-tx)}
    \[
    |T.\text{key\_images}| = |\{I : I \in T.\text{key\_images}\}|
    \]

  \item $P_4$: \textbf{Ring Validity}
    \[
    \forall r \in T.\text{rings}: |r| = 20 \land \forall o \in r: o \in \Sigma.\mathcal{U}
    \]

  \item $P_5$: \textbf{Signature Validity}
    \[
    \forall (r, \sigma, I) \in \text{zip}(T.\text{rings}, T.\text{sigs}, T.\text{key\_images}):
    \text{CLSAG.Verify}(r, \sigma, I, T.\text{hash})
    \]

  \item $P_6$: \textbf{Value Conservation}
    \[
    \sum_{i} C_{\text{in}}^{(i)} = \sum_{j} C_{\text{out}}^{(j)} + T.\text{fee} \cdot H
    \]

  \item $P_7$: \textbf{Range Proofs}
    \[
    \text{Bulletproof.Verify}(T.\text{proof}, \{C_{\text{out}}^{(j)}\})
    \]

  \item $P_8$: \textbf{Fee Sufficiency}
    \[
    T.\text{fee} \geq f_{\text{base}} \cdot |T|_{\text{bytes}} \cdot \phi(T)
    \]
    where $\phi(T)$ is the cluster factor
\end{enumerate}

\subsubsection{Block Validity}

A block $B$ is valid with respect to state $\Sigma$ iff:

\begin{equation}
\text{Valid}(B, \Sigma) \Leftrightarrow \bigwedge_{i=1}^{6} Q_i(B, \Sigma)
\end{equation}

where predicates $Q_i$ are:

\begin{enumerate}
  \item $Q_1$: \textbf{Chain Linkage}
    \[
    B.\text{prev\_hash} = \Hash(\Sigma.\text{latest\_block})
    \]

  \item $Q_2$: \textbf{Height Increment}
    \[
    B.\text{height} = \Sigma.h + 1
    \]

  \item $Q_3$: \textbf{Proof of Work}
    \[
    \Hash(B.\text{header}) < B.\text{target}
    \]

  \item $Q_4$: \textbf{Timestamp Validity}
    \[
    \Sigma.t < B.t \leq \text{now} + \epsilon
    \]

  \item $Q_5$: \textbf{Minting Validity}
    \[
    \sum B.\text{mint}.\text{outputs} \leq R(B.\text{height}) \land
    \text{ML-DSA.Verify}(B.\text{mint}.\text{sig})
    \]

  \item $Q_6$: \textbf{Transaction Validity}
    \[
    \forall T \in B.\text{transactions}: \text{Valid}(T, \Sigma')
    \]
    where $\Sigma'$ is state after applying preceding transactions
\end{enumerate}

\subsection{SCP State Machine}

\subsubsection{Message Types}

\begin{lstlisting}[caption={SCP message types}]
enum SCPMessage {
    Nominate {
        slot: u64,
        voted: Set<Value>,
        accepted: Set<Value>,
    },
    Prepare {
        slot: u64,
        ballot: Ballot,
        prepared: Option<Ballot>,
        prepared_prime: Option<Ballot>,
        quorum_set_hash: Hash,
    },
    Commit {
        slot: u64,
        ballot: Ballot,
        prepared_counter: u32,
        quorum_set_hash: Hash,
    },
    Externalize {
        slot: u64,
        commit: Ballot,
        quorum_set_hash: Hash,
    },
}

struct Ballot {
    counter: u32,
    value: Value,  // Block hash
}
\end{lstlisting}

\subsubsection{State Transitions}

\begin{lstlisting}[caption={SCP state machine}]
function process_scp_message(
    state: SCPState,
    msg: SCPMessage,
    sender: NodeId
) -> SCPState {
    match msg {
        Nominate { slot, voted, accepted } => {
            // Update nomination state
            for v in voted {
                if sender in state.quorum_slice {
                    state.slots[slot].voted.insert(v)
                }
            }
            for v in accepted {
                if has_blocking_set(state, sender, v) {
                    state.slots[slot].accepted.insert(v)
                }
            }

            // Check if nomination complete
            if has_quorum(state, state.slots[slot].accepted) {
                state.slots[slot].phase = PREPARING
                let value = pick_composite_value(state.slots[slot].accepted)
                state.slots[slot].ballot = Ballot { counter: 1, value }
            }
        },

        Prepare { slot, ballot, .. } => {
            // Process prepare vote
            if state.slots[slot].phase >= PREPARING {
                update_prepare_state(state, slot, ballot, sender)

                // Check for commit transition
                if can_commit(state, slot) {
                    state.slots[slot].phase = COMMITTING
                }
            }
        },

        Commit { slot, ballot, .. } => {
            // Process commit vote
            if state.slots[slot].phase >= COMMITTING {
                update_commit_state(state, slot, ballot, sender)

                // Check for externalize
                if has_quorum_commit(state, slot) {
                    state.slots[slot].phase = EXTERNALIZED
                    emit_externalize(state, slot)
                }
            }
        },

        Externalize { slot, commit, .. } => {
            // Accept externalize from quorum
            if has_quorum_externalize(state, slot, commit) {
                state.slots[slot].phase = EXTERNALIZED
                state.slots[slot].externalized_value = Some(commit.value)
            }
        },
    }

    state
}
\end{lstlisting}

\subsection{Invariants}

The following invariants are maintained:

\begin{enumerate}
  \item \textbf{Key Image Uniqueness}
    \[
    \forall I \in \mathcal{I}: |\{T : I \in T.\text{key\_images}\}| = 1
    \]

  \item \textbf{UTXO Conservation}
    \[
    \sum_{U \in \mathcal{U}} \text{value}(U) + \text{burned} = \text{total\_minted}
    \]

  \item \textbf{Cluster Tag Normalization}
    \[
    \forall U \in \mathcal{U}: \sum_{c} U.\text{cluster\_tag}.\text{weights}[c] = 1
    \]

  \item \textbf{SCP Safety}
    \[
    \forall s, v_1, v_2: \text{externalized}(s, v_1) \land \text{externalized}(s, v_2) \Rightarrow v_1 = v_2
    \]

  \item \textbf{Chain Integrity}
    \[
    \forall h > 0: B_h.\text{prev\_hash} = \Hash(B_{h-1})
    \]
\end{enumerate}

These invariants can be checked by a model checker or used as assertions in
implementation testing.
