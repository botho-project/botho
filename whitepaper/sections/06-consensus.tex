% ============================================================================
% Section 6: Consensus Mechanism
% ============================================================================

\section{Consensus Mechanism}
\label{sec:consensus}

\Botho employs a hybrid consensus mechanism combining proof-of-work (PoW)
block proposal with Stellar Consensus Protocol (SCP) finalization. This
achieves permissionless participation with fast deterministic finality.

\subsection{Design Rationale}

\subsubsection{Why Not Pure PoW?}

Nakamoto consensus provides permissionless participation but suffers from:
\begin{itemize}
  \item \textbf{Slow finality}: Probabilistic finality requires multiple
    confirmations (typically 10--60 minutes).
  \item \textbf{Reorg vulnerability}: Transactions can be reversed by chain
    reorganizations, even after confirmation.
  \item \textbf{Energy waste}: Hashpower expended on orphaned blocks provides
    no value.
\end{itemize}

\subsubsection{Why Not Pure BFT?}

Classical BFT protocols provide deterministic finality but require:
\begin{itemize}
  \item \textbf{Known participants}: Fixed validator sets conflict with
    permissionless design.
  \item \textbf{Quadratic messaging}: $O(n^2)$ communication limits
    scalability.
  \item \textbf{Synchrony assumptions}: Liveness depends on network timing
    bounds.
\end{itemize}

\subsubsection{Hybrid Approach}

\Botho combines the strengths of both:
\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Property} & \textbf{PoW} & \textbf{SCP} \\
\midrule
Permissionless participation & \checkmark & --- \\
Fair distribution & \checkmark & --- \\
Deterministic finality & --- & \checkmark \\
Fast confirmation & --- & \checkmark \\
Byzantine fault tolerance & --- & \checkmark \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Stellar Consensus Protocol}
\label{sec:scp}

SCP achieves Byzantine agreement with open membership through
\textit{federated Byzantine agreement} (FBA).

\subsubsection{Quorum Slices}

Each node $v$ declares a \textit{quorum slice} $Q(v)$---the set of nodes
$v$ trusts for consensus. Unlike classical BFT where all nodes agree on
membership, SCP allows heterogeneous trust:

\begin{definition}[Quorum Slice]
A quorum slice for node $v$ is a set $Q(v) \subseteq V$ such that $v \in Q(v)$
and $v$ will accept a statement if all nodes in $Q(v)$ accept it.
\end{definition}

\begin{definition}[Quorum]
A set $U \subseteq V$ is a quorum if for every node $v \in U$, there exists
a quorum slice $Q(v) \subseteq U$.
\end{definition}

Informally, a quorum is a set of nodes sufficient for agreement---each member
has ``enough'' trusted nodes within the set to be convinced.

\subsubsection{Quorum Intersection}

Safety requires that any two quorums overlap:

\begin{definition}[Quorum Intersection]
A system has quorum intersection if for all quorums $U_1, U_2$:
$U_1 \cap U_2 \neq \emptyset$.
\end{definition}

\begin{theorem}[SCP Safety]
If the network has quorum intersection and no Byzantine nodes, then SCP
provides safety: no two honest nodes externalize different values for the
same slot.
\end{theorem}

\subsubsection{Tiered Quorum Structure}

\Botho uses a tiered quorum structure balancing decentralization with
robustness:

\begin{lstlisting}[language=,caption={Default quorum slice configuration}]
QuorumSlice {
    // Tier 1: Infrastructure nodes (high-uptime, well-connected)
    threshold: 3,
    validators: [
        "node1.botho.org",
        "node2.botho.org",
        "node3.botho.org",
        "node4.botho.org",
    ],
    // Tier 2: Community validators
    inner_sets: [
        {
            threshold: 2,
            validators: ["community1", "community2", "community3"],
        },
    ],
}
\end{lstlisting}

This requires agreement from 3 of 4 infrastructure nodes AND 2 of 3
community validators, ensuring both stability and decentralization.

\subsection{Consensus Phases}

The consensus process proceeds through four phases for each block slot:

\subsubsection{Phase 1: Block Proposal (PoW)}

Miners compete to propose blocks via proof-of-work:

\begin{enumerate}
  \item Miner constructs candidate block with transactions from mempool
  \item Miner searches for nonce satisfying:
    \begin{equation}
    \Hash(\text{block\_header} \| \text{nonce}) < \text{target}
    \end{equation}
  \item First valid block is broadcast to the network
  \item Multiple proposals may arrive; SCP selects among them
\end{enumerate}

\textbf{Why PoW for proposal?}
\begin{itemize}
  \item \textbf{Permissionless}: Anyone can propose blocks
  \item \textbf{Fair distribution}: Block rewards are distributed by
    computational contribution
  \item \textbf{Sybil resistance}: Creating proposals requires real resources
\end{itemize}

\subsubsection{Phase 2: Nomination}

Nodes nominate candidate values (block hashes) for the slot:

\begin{enumerate}
  \item Node receives valid block proposals
  \item Node nominates the first valid proposal received (tie-breaking by
    lowest hash)
  \item Nodes accept nominations from their quorum slices
  \item Nomination converges to a single candidate when a quorum agrees
\end{enumerate}

\begin{lstlisting}[language=,caption={Nomination message structure}]
NominationMessage {
    slot_index: u64,
    voted: Vec<BlockHash>,      // Values this node votes for
    accepted: Vec<BlockHash>,   // Values this node has accepted
}
\end{lstlisting}

\subsubsection{Phase 3: Ballot Protocol}

Once nomination produces a candidate, nodes run the ballot protocol to
commit to a specific value:

\begin{enumerate}
  \item \textbf{Prepare}: Nodes vote to prepare a ballot $(n, v)$ where
    $n$ is a counter and $v$ is the candidate value
  \item \textbf{Commit}: Once prepared, nodes vote to commit the ballot
  \item \textbf{Abort}: If a ballot cannot progress, nodes abort and try
    a higher ballot number
\end{enumerate}

The ballot protocol ensures:
\begin{itemize}
  \item No two different values can be committed for the same slot
  \item Progress is made despite Byzantine nodes (up to threshold)
  \item Aborted ballots do not block future ballots
\end{itemize}

\subsubsection{Phase 4: Externalize}

When a ballot is committed, nodes externalize the value:

\begin{lstlisting}[language=,caption={Externalize message structure}]
ExternalizeMessage {
    slot_index: u64,
    commit: Ballot,              // The committed ballot
    quorum_set_hash: Hash,       // Proves quorum agreement
}
\end{lstlisting}

Externalization represents deterministic finality---the value cannot be
changed without violating quorum intersection.

\subsection{Block Structure}

\begin{lstlisting}[language=,caption={Block structure}]
Block {
    header: BlockHeader,
    minting_tx: MintingTransaction,
    transactions: Vec<PrivateTransaction>,
    scp_proof: SCPProof,
}

BlockHeader {
    version: u8,
    prev_block_hash: Hash,
    merkle_root: Hash,
    timestamp: u64,
    height: u64,
    difficulty: u64,
    nonce: u64,
    minter_public_key: MLDSAPublicKey,
}

SCPProof {
    slot_index: u64,
    externalize_messages: Vec<ExternalizeMessage>,
    // Sufficient messages to prove quorum agreement
}
\end{lstlisting}

\subsection{Difficulty Adjustment}

\Botho uses a responsive difficulty adjustment algorithm:

\begin{equation}
\text{difficulty}_{n+1} = \text{difficulty}_n \times \frac{T_{\text{target}}}{T_{\text{actual}}}
\end{equation}

where:
\begin{itemize}
  \item $T_{\text{target}}$ is the target block time (dynamically adjusted,
    see Section~\ref{sec:monetary})
  \item $T_{\text{actual}}$ is the actual time for the last adjustment
    window (144 blocks)
\end{itemize}

Adjustments are bounded to $[0.5, 2.0]\times$ per window to prevent
oscillation.

\subsection{Fork Resolution}

Unlike pure PoW where the longest chain wins, \Botho's SCP finalization
makes forks impossible for externalized blocks:

\begin{theorem}[Fork Freedom]
If the network has quorum intersection and the Byzantine threshold is
not exceeded, no two honest nodes can externalize different blocks at
the same height.
\end{theorem}

\begin{proof}[Proof sketch]
Suppose nodes $A$ and $B$ externalize different blocks $b_A \neq b_B$ at
height $h$. Externalization requires a quorum $Q_A$ agreeing on $b_A$ and
$Q_B$ agreeing on $b_B$. By quorum intersection, $Q_A \cap Q_B \neq \emptyset$.
Any honest node in the intersection would have voted for both values,
violating the ballot protocol's safety invariant.
\end{proof}

\textbf{Handling pre-finalization forks}: Multiple PoW proposals may arrive
before SCP converges. The nomination phase selects a unique winner based on:
\begin{enumerate}
  \item First valid proposal received (per node)
  \item Tie-breaking by lowest block hash
  \item Quorum agreement determines final selection
\end{enumerate}

\subsection{Timing Analysis}

\begin{table}[h]
\centering
\caption{Consensus timing breakdown}
\label{tab:timing}
\begin{tabular}{@{}lr@{}}
\toprule
\textbf{Phase} & \textbf{Time} \\
\midrule
Block proposal (PoW) & Variable (5--40s target) \\
Nomination & $\sim$1s \\
Ballot prepare & $\sim$1s \\
Ballot commit & $\sim$1s \\
Externalize & $<$1s \\
\midrule
\textbf{Total finality} & Block time + $\sim$3--4s \\
\bottomrule
\end{tabular}
\end{table}

In practice, finality occurs within 5 seconds of block proposal, compared
to 10--60 minutes for pure PoW systems.

\subsection{Liveness Guarantees}

\begin{theorem}[SCP Liveness]
If the network is eventually synchronous and at most $f$ nodes are Byzantine
(where each quorum can tolerate $f$ failures), then SCP eventually makes
progress.
\end{theorem}

\textbf{Graceful degradation}: If quorum intersection fails (e.g., due to
network partition), safety is preserved---nodes simply halt rather than
fork. This is a conscious design choice: safety over liveness.

\subsection{Security Properties}

\subsubsection{Byzantine Fault Tolerance}

The system tolerates Byzantine behavior from nodes outside any quorum's
blocking threshold. For the default tier structure:
\begin{itemize}
  \item Infrastructure tier: 1 of 4 can be Byzantine
  \item Community tier: 1 of 3 can be Byzantine
\end{itemize}

\subsubsection{Nothing-at-Stake Resistance}

Unlike pure proof-of-stake systems, PoW proposal ensures:
\begin{itemize}
  \item Proposing multiple blocks requires multiple PoW solutions
  \item Resources are burned regardless of which block is selected
  \item No advantage to ``voting for everything''
\end{itemize}

\subsubsection{Long-Range Attack Resistance}

SCP finality prevents long-range attacks:
\begin{itemize}
  \item Once externalized, blocks cannot be reverted
  \item Rewriting history requires corrupting quorum intersection
  \item No ``weak subjectivity'' bootstrap problem
\end{itemize}

\subsection{Comparison with Alternatives}

\begin{table}[h]
\centering
\caption{Consensus mechanism comparison}
\label{tab:consensus-comparison}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Property} & \textbf{\Botho} & \textbf{Bitcoin} & \textbf{Tendermint} \\
\midrule
Finality & Deterministic & Probabilistic & Deterministic \\
Finality time & $\sim$5--10s & $\sim$60 min & $\sim$6s \\
Permissionless & Yes & Yes & No \\
Fork possible & No & Yes & No \\
Byzantine tolerance & Quorum-based & 50\% hashpower & 1/3 validators \\
Energy efficiency & Medium & Low & High \\
\bottomrule
\end{tabular}
\end{table}

